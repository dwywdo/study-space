> 원문: https://highscalability.com/what-the-heck-are-you-actually-using-nosql-for/

우리는 흔히 “일에 맞는 올바른 도구를 선택해야 한다”는 말을 합니다. 누구나 그렇게 말하고, 반박할 사람도 없습니다. 하지만 이 말은 보다 구체적인 질문들에 답할 수 없으면 별 도움이 되지 않습니다. 예를 들어:

- 각 도구는 어떤 일에 적합한가?
    
- 내 업무와 유사한 작업에도 잘 작동할까?
    
- 팀원들이 이미 익숙한 도구를 두고, 마감이 촉박한 상황에서 새로운 걸 시도하는 게 과연 위험을 감수할 만한가?
    
- 모든 도구를 어떻게 조화롭게 쓸 수 있을까?
    

NoSQL 분야에서는 이런 실전 데이터가 아직 모호한 편입니다. 벤더들에게 물어보면 대부분 “NoSQL은 빅데이터나 키-값 접근에 좋다” 같은 일반적인 답변을 합니다. 그런데 구체적인 문제를 해결해야 하는 현업 개발자 입장에서, 선택지는 수두룩한데 명확한 우승자는 없고, 이런 일반론적인 설명만 들으면 뭐가 도움이 될까요? 거의 없습니다. 자신의 문제를 어떤 방식으로 해결할 수 있을지, 정말 수고스럽고 위험을 감수할 가치가 있는지를 상상하기가 어려운 게 현실입니다.

이 상황을 바꿔봅시다.  
당신은 NoSQL을 어떤 문제를 해결하기 위해 사용하고 있나요?  
어떤 제품을 쓰고 있나요?  
그게 어떤 식으로 도움이 되고 있나요?

물론 이 질문은 제가 12월 14일에 진행할 웨비나를 위한 리서치의 일부이기도 합니다. 하지만 저는 사람들이 사례를 통해 가장 잘 배운다고 굳게 믿고 있습니다. 그러니 우리가 구체적인 사례들을 함께 만들어낼 수 있다면, 다른 사람들이 이 다양한 신제품들을 자신들의 시스템에 어떻게 효과적으로 활용할 수 있을지 상상하는 데 큰 도움이 될 것입니다.

제가 인터넷을 돌아다니며 수집한 사용 사례들을 아래에 정리해두었습니다. 출처가 너무 다양해서 하나하나 인용하기는 어렵지만, 마지막에 참고 목록을 따로 붙일 예정입니다. 여러분의 사례도 자유롭게 추가해 주세요. 특정 제품에 대한 사용 사례가 많았던 경우에는 별도로 분리해서 나열했는데, 그저 더 명확하게 보이기 위해서일 뿐, 특정 제품을 추천하는 의도는 아닙니다. 아래는 모든 NoSQL 제품의 마스터 리스트입니다. 만약 특정 제품에 대해 사례 모음을 제공해 주신다면, 기꺼이 그 부분을 추가하겠습니다.


### 일반적인 사용 사례

#### 1. **거대함(Bigness)**

NoSQL은 새로운 데이터 스택의 핵심 구성 요소로 여겨지며, 빅데이터, 대규모 사용자 수, 대규모 서버 수, 거대한 공급망, 거대한 과학 프로젝트 등, 모든 “거대한” 것들을 지원합니다. 규모가 너무 커서 분산 시스템이 필수일 때, NoSQL이 그 자리를 차지합니다. 단, 모든 NoSQL 시스템이 “거대함”을 지향하는 것은 아닙니다. 여기서 말하는 거대함은 단순히 디스크 용량만이 아니라 여러 차원에서의 확장성을 의미합니다.

#### 2. **엄청난 쓰기 성능**

아마도 구글의 영향으로 가장 대표적인 NoSQL의 활용 방식입니다. 예를 들어 Facebook은 매달 1,350억 개의 메시지를 저장해야 하고, Twitter는 하루에 7TB의 데이터를 저장해야 합니다(이 수치는 해마다 몇 배씩 증가할 가능성이 있음). 이건 단순히 "한 노드에 데이터가 다 안 들어간다"는 문제입니다. 초당 80MB 속도로도 7TB를 저장하려면 하루가 걸립니다. 따라서 분산 클러스터를 통해 데이터를 저장해야 하고, 이는 키-값 접근, MapReduce, 복제, 장애 허용성, 일관성 문제 등 다양한 요소를 포함합니다. 더 빠른 쓰기를 위해 인메모리 시스템이 사용되기도 합니다.

#### 3. **빠른 키-값 접근**

아마도 사람들이 NoSQL을 선택하는 두 번째 주요 이유일 것입니다. 지연(latency)이 중요한 상황에서는, 키에 해싱하고 메모리 또는 단 한 번의 디스크 탐색으로 값을 읽는 것이 매우 효과적입니다. 물론 모든 NoSQL 제품이 빠른 접근을 보장하는 것은 아닙니다. 일부는 안정성을 더 중시합니다. 하지만 많은 사람들이 오랫동안 더 나은 memcached를 원해 왔고, 많은 NoSQL 시스템이 그 역할을 해주고 있습니다.

#### 4. **유연한 스키마와 데이터 타입**

NoSQL은 다양한 새로운 데이터 타입을 지원합니다. 컬럼 기반(column-oriented), 그래프, 고급 자료구조, 문서 지향(document-oriented), 키-값 등 다양한 모델이 존재합니다. 복잡한 객체를 복잡한 매핑 없이 쉽게 저장할 수 있습니다. 개발자들은 복잡한 스키마나 ORM 프레임워크를 회피하고 싶어하며, 구조가 없거나 느슨한 구조는 훨씬 더 유연함을 제공합니다. 또한 JSON과 같은 개발자 친화적인 타입도 쉽게 다룰 수 있습니다.

#### 5. **스키마 마이그레이션**

스키마가 없는(seamless) 구조 덕분에 스키마 변경이 수월합니다. 런타임에 애플리케이션에 의해 스키마가 정의되기 때문에, 애플리케이션의 각 부분은 서로 다른 스키마 관점을 가질 수 있습니다.

#### 6. **쓰기 가용성 (Write Availability)**

무슨 일이 있어도 쓰기가 반드시 성공해야 하는 경우라면, 파티셔닝, CAP 이론, 결국적 일관성(eventual consistency) 등의 이슈가 중요해집니다.

#### 7. **쉬운 유지관리, 운영**

제품에 따라 다르지만, 많은 NoSQL 벤더들은 개발자들이 쉽게 도입할 수 있도록 사용자 친화성, 최소한의 설정, 자동화된 운영 등에 집중하고 있습니다. 이를 통해 별도의 스케일링 코드를 작성하지 않아도 되며 운영 비용이 절감됩니다.

#### 8. **단일 장애 지점 없음 (No Single Point of Failure)**

모든 제품이 이 특성을 보장하는 것은 아니지만, 자동 로드 밸런싱과 클러스터 크기 조정 등을 통해 고가용성을 쉽게 구성하고 관리할 수 있는 방향으로 수렴 중입니다. 클라우드 환경에 매우 적합합니다.

#### 9. **병렬 컴퓨팅 지원**

많은 제품들이 MapReduce를 기본 내장하고 있어, 병렬 처리가 앞으로는 개발의 일상적인 부분이 될 것입니다.

#### 10. **개발자 친화성**

데이터 접근이 쉬워야 합니다. 관계형 모델은 회계사 등 최종 사용자에게는 직관적이지만, 개발자에게는 그렇지 않습니다. 개발자는 키, 값, JSON, JavaScript 기반 저장 프로시저, HTTP 등과 친숙합니다. NoSQL은 개발자를 위한 도구입니다. 이는 일종의 개발자 주도의 혁명입니다. “DB 문제? DBA 고용해서 스키마 튜닝하고 부분 비정규화하면 되지”라는 답변은 점점 더 거부되고 있으며, 개발자 스스로 시스템을 구성하고 운영할 수 있길 원합니다. 게다가 비용 문제도 있습니다. 확장하는 데 드는 비용이 크다면, 더 저렴하고 개발자가 제어 가능하며 확장 쉬운 시스템으로 갈 것입니다.

#### 11. **문제에 맞는 데이터 모델 사용**

문제에 따라 적합한 데이터 모델이 다릅니다. 예를 들어 그래프 연산을 RDBMS에 억지로 끼워 넣는 데 많은 노력이 들었지만, 제대로 작동하지 않습니다. 그래프 문제는 그래프 DB로 푸는 것이 더 낫습니다. 요즘은 문제와 솔루션 사이에 가장 잘 맞는 조합을 찾으려는 전략이 일반화되고 있습니다.

#### 12. **확장의 한계 돌파**

많은 프로젝트가 확장성과 성능의 벽에 부딪힙니다. 더 이상 개선 여지가 없을 때, 점진적인 리소스 추가로 선형 확장이 가능한 제품을 선택하는 것은 큰 장점입니다. 예전엔 이런 것이 불가능했지만, 지금은 바로 사용 가능한 제품들이 존재합니다.

#### 13. **분산 시스템 지원**

모든 사용자가 반드시 초대형 규모나 성능을 요구하는 것은 아닙니다. 이들이 원하는 것은 데이터 센터를 가로지르며 장애 상황도 문제없이 처리할 수 있는 분산 시스템입니다. NoSQL은 확장성에 초점을 두기 때문에 파티셔닝을 잘 활용하고, 무거운 일관성 프로토콜을 피하는 경향이 있어, 이런 분산 환경에 잘 어울립니다.

#### 14. **조정 가능한 CAP 트레이드오프**

NoSQL은 CAP 이론의 스펙트럼 상에서 어느 지점을 선택할지 "슬라이더"처럼 조절할 수 있는 유일한 종류의 제품입니다. 전통적인 RDBMS는 강한 일관성을 택하고 있어 파티션 분할에 취약합니다. 결국 이는 비즈니스 결정이며, 애플리케이션마다 다르게 판단되어야 합니다.

- 여러분의 앱은 일관성이 얼마나 중요한가요?
    
- 약간의 데이터 손실이 허용되나요?
    
- 강한 일관성이 필요한가요, 약한 일관성도 괜찮은가요?
    
- 가용성이 더 중요한가요, 아니면 정확성이 더 중요한가요?
    
- 장애로 인해 시스템이 다운되는 것이, 잘못된 데이터가 처리되는 것보다 더 큰 손해인가요?
    

이처럼 선택권을 제공하는 제품이 있다는 것은 매우 유용한 일입니다.

### 보다 구체적인 사용 사례

- **대규모 비트랜잭션 데이터 스트림 관리**: Apache 로그, 애플리케이션 로그, MySQL 로그, 클릭스트림 등.
    
- **온라인/오프라인 데이터 동기화**: 이 분야는 CouchDB가 타겟으로 삼는 틈새 시장입니다.
    
- **모든 부하 상황에서 빠른 응답 시간 유지**.
    
- **복잡한 조인에 의한 높은 쿼리 부하 회피**: RDBMS가 감당하기 어려울 정도로 조인이 많을 때.
    
- **소프트 실시간 시스템**: 낮은 지연 시간이 중요한 경우. 예: 게임.
    
- **다양한 읽기/쓰기/쿼리/일관성 패턴 지원이 필요한 애플리케이션**:
    
    - 읽기 50% / 쓰기 50% 최적화 시스템
        
    - 쓰기 95% / 읽기 5% 최적화 시스템
        
    - 읽기 전용, 극한의 속도와 복원력을 요구하며, 간단한 쿼리 및 약간의 데이터 지연을 허용하는 시스템
        
    - 중간 수준의 성능, 읽기/쓰기 가능, 단순한 쿼리, 완전한 신뢰성 있는 데이터가 필요한 시스템
        
    - 복잡한 쿼리를 요구하는 읽기 전용 애플리케이션
        
- **데이터 집중/사용 집중에 따라 로드 밸런싱 수행 및 마이크로프로세서 자원 활용도 향상**.
    
- **실시간 삽입, 갱신, 쿼리 처리**.
    
- **계층적 데이터 구조**: 예를 들어, 스레드 기반 토론, 부품 폭발 구조(BOM).
    
- **동적 테이블 생성**.
    
- **2단계 애플리케이션 구조**: 빠른 NoSQL 인터페이스로 낮은 지연 시간 데이터 제공, 계산 및 갱신은 Hadoop 등 고지연 시스템이 수행.
    
- **순차적 데이터 읽기**: 저장소 모델이 중요함. 순차 읽기에는 B-tree가 적합하지 않을 수 있음.
    
- **특정 기능을 별도의 시스템으로 분리해 성능/확장성 개선**: 예를 들어, 사용자 로그인 기능은 전용 서비스로 분리해 고성능을 유지.
    
- **캐싱**: 웹사이트나 기타 애플리케이션을 위한 고성능 캐시 계층. 예: 대형 하드론 충돌기의 데이터 집계 시스템을 위한 캐시.
    
- **투표 시스템**.
    
- **실시간 페이지 뷰 카운터**.
    
- **사용자 등록, 프로필, 세션 데이터 관리**.
    
- **문서 및 콘텐츠 관리 시스템**: 복잡한 문서를 관계형 테이블로 나누지 않고 전체 형태로 저장 가능. 재고, 쇼핑카트, 기타 구조화된 데이터도 유사한 논리 적용 가능.
    
- **아카이빙**: 지속적으로 생성되는 대규모 데이터를 온라인에서 접근 가능한 형태로 저장. 시간이 지나면서 변경되는 스키마를 유연하게 처리할 수 있는 문서 지향 데이터베이스 사용.
    
- **분석(Analytics)**: MapReduce, Hive, Pig 등을 사용한 분석 쿼리 수행, 높은 쓰기 부하를 감당할 수 있는 수평 확장 시스템 사용.
    
- **이기종 데이터 타입 처리**: 다양한 미디어 타입을 일반적인 수준에서 다룸.
    
- **임베디드 시스템**: SQL과 서버의 오버헤드를 피하고, 더 간단한 저장소를 사용하는 경우.
    
- **‘마켓’ 게임 시나리오**:
    
    - 마을에 건물을 소유한 사용자의 건물 목록을 빠르게 조회하고 싶을 때: 건물 테이블의 소유자(owner) 컬럼으로 파티셔닝하면 단일 파티션 조회로 해결.
        
    - 누군가가 다른 사람의 건물을 구매할 경우, 소유자와 가격을 업데이트함.
        
- **NASA JPL**: SimpleDB를 사용해 로버 계획의 속성 저장. 전체 계획 blob은 S3에 저장됨.
    
- **연방 법집행 기관**: 신용카드, 멤버십 카드, 여행 예약 데이터를 실시간으로 추적해 미국 시민 감시.
    
- **실시간 사기 탐지**: 트랜잭션을 기존 패턴과 비교해 실시간으로 감지.
    
- **환자 이력을 통합해 종양의 유형 진단**.
    
- **고빈도 갱신 상황에서 인메모리 데이터베이스 사용**: 예: 사용자 "최근 활동" 시간을 실시간으로 표시하는 웹사이트. 사용자가 30초마다 활동할 경우, 동시 사용자 약 5000명 정도가 한계.
    
- **낮은 빈도의 다중 파티션 쿼리는 materialized view로 처리하면서, 고빈도 스트리밍 데이터는 계속 처리**.
    
- **우선순위 큐(Priority queues)**.
    
- **캐시된 데이터에 대해 ORM 없이 계산 수행**: 프로그래머 친화적 인터페이스 사용.
    
- **단순 키-값 컬럼을 이용한 대용량 데이터셋의 유일성 확인**.
    
- **빠른 쿼리를 유지하기 위해 데이터를 시간 단위로 롤업(집계)**.
    
- **조인으로는 느린 두 개의 거대한 집합의 교집합 계산**.
    
- **Twitter 스타일의 타임라인 처리**.
    
### VoltDB 사용 사례

VoltDB는 관계형 데이터베이스이지만, 전통적인 Oracle 계열 시스템과는 매우 다른 급진적인 설계 철학을 가지고 있어 **NoSQL 계열에 더 가깝다고 볼 수 있습니다**.

---

#### 📌 **애플리케이션: 금융 거래 모니터링**

- **데이터 소스:** 실시간 시장 데이터
    
- **파티션 키:** 시장 심볼 (티커, CUSIP, SEDOL 등)
    
- **고빈도 작업:** 모든 거래 기록 및 인덱싱, 틱 데이터 저장 (호가/매도)
    
- **저빈도 작업:** 20개 이상의 조건으로 거래 주문 세부 정보 검색, 특정 트레이더의 모든 시장 심볼에 대한 포지션 조회
    

---

#### 📌 **애플리케이션: 웹 봇 취약점 스캐닝 (SaaS 애플리케이션)**

- **데이터 소스:** 수신 HTTP 요청
    
- **파티션 키:** 고객 URL
    
- **고빈도 작업:** 요청 기록, 분석 및 경고 처리
    
- **저빈도 작업:** 취약점 탐지, 고객 리포트 생성
    

---

#### 📌 **애플리케이션: 온라인 게임 리더보드**

- **데이터 소스:** 온라인 게임
    
- **파티션 키:** 게임 ID
    
- **고빈도 작업:** 특정 구간별 점수 랭킹, 플레이어의 개인 최고 기록 반영
    
- **저빈도 작업:** 리더보드 조회
    

---

#### 📌 **애플리케이션: 택배 추적 (물류)**

- **데이터 소스:** 센서 스캔
    
- **파티션 키:** 배송 ID
    
- **고빈도 작업:** 실시간 위치 업데이트
    
- **저빈도 작업:** 패키지 상태 리포트(이력 포함), 분실 추적, 배송 경로 재설정
    

---

#### 📌 **애플리케이션: 광고 콘텐츠 제공**

- **데이터 소스:** 웹사이트 또는 디바이스, 사용자 트리거 또는 규칙 기반
    
- **파티션 키:** 공급업체/광고 ID 조합
    
- **고빈도 작업:** 공급업체 잔액 확인, 광고 제공(타겟 디바이스 포맷에 맞게), 잔액 업데이트
    
- **저빈도 작업:** 실시간 광고 조회 및 클릭률 통계 리포트 (공급업체 요청 기반)
    

---

#### 📌 **애플리케이션: 전화 교환기 통화 상세 기록(CDR) 관리**

- **데이터 소스:** 통화 시작 요청
    
- **파티션 키:** 발신자 ID
    
- **고빈도 작업:** 실시간 인증 (요금제 및 잔액 기반)
    
- **저빈도 작업:** 사기 탐지/분석
    

---

#### 📌 **애플리케이션: 항공권 예약 및 발권**

- **데이터 소스:** 고객(웹), 항공사(웹 및 내부 시스템)
    
- **파티션 키:** 고객 (항공편 정보는 복제됨)
    
- **고빈도 작업:** 좌석 선택(임대 시스템), 좌석 추가/제거, 수하물 체크인
    
- **저빈도 작업:** 항공편 좌석 및 스케줄 조회, 결항 시 승객 재예약
    


### 분석(Analytics) 사용 사례

Twitter의 Kevin Weil은 **Hadoop을 활용한 사용 사례**를 잘 소개하고 있습니다.  
Twitter에서는 다음과 같은 방식으로 Hadoop을 사용합니다:

- **기본 통계 수집**: 합계, 최소/최대값, 표준편차 계산
    
- **데이터 상관 분석**: 확률, 공분산, 영향력 분석
    
- **빅데이터 기반의 리서치**
    

> Hadoop은 NoSQL의 경계에 있지만, 어떤 문제들을 해결하고 있는지를 보는 데 매우 유용합니다.

---

#### 📊 분석 질문 예시

- 매일 몇 건의 요청을 처리하는가?
    
- 평균 지연 시간은? 95% 지연 시간은?
    
- 응답 코드별로 분류할 때, 시간대별 분포는?
    
- Twitter에서 매일 얼마나 많은 검색이 일어나는가?
    
- 검색 요청은 어디서 오는가?
    
- 얼마나 많은 **고유한 검색어**가 존재하는가?
    
- 얼마나 많은 **고유 사용자**가 있는가?
    
- 지리적 분포는 어떻게 되는가?
    
- **모바일 사용자**는 사용 패턴이 어떻게 다른가?
    
- **3rd-party 데스크탑 클라이언트 사용자**는 어떻게 다른가?
    

---

#### 🧑‍🤝‍🧑 사용자 행동 분석

- **코호트 분석(Cohort Analysis)**: 같은 날 가입한 사용자들이 시간이 지나며 어떻게 달라지는가?
    
- **사이트 문제 탐지**: 동시에 어떤 문제들이 발생하는가?
    
- **사용자를 사로잡는 기능은 무엇인가?**
    
- **성공적인 사용자들이 자주 사용하는 기능은 무엇인가?**
    

---

#### 🔍 검색 및 트윗 분석

- **검색 자동 수정 및 추천 기능**  
    (현재 Twitter에서는 적용하지 않았지만, 향후 도입 예정)
    
- 사용자의 트윗에서 웹은 무엇을 파악할 수 있는가?
    
- **팔로우하는 사람들의 트윗**을 통해 당신에 대해 무엇을 알 수 있는가?
    
- **당신을 팔로우하는 사람들의 트윗**으로 무엇을 유추할 수 있는가?
    
- 팔로워/팔로잉 비율을 통해 어떤 정보를 얻을 수 있는가?
    

---

#### 🌐 소셜 그래프 & 트윗 확산 분석

- **어떤 그래프 구조**가 성공적인 네트워크로 이어지는가?  
    (Twitter는 양방향이 아닌 **단방향 구조**로 이 점이 흥미롭다)
    
- **트윗이 리트윗**되도록 만드는 요소는 무엇인가?
    
- 트윗이 리트윗될 때, **리트윗 트리의 깊이**는 얼마나 되는가?
    

---

#### 🤖 기타 분석 주제

- **장기 중복 트윗 탐지** (단기적으로는 악용/스팸 방지용)
    
- **머신 러닝**:  
    → 처음에는 올바른 질문조차 알기 어려움  
    → 사용자 군집화(클러스터링)는 어떻게 할 수 있을까?
    
- **언어 감지**:  
    → SMS 요금 할인 계약을 위해 사용자 언어 파악 (처음엔 인기 국가 중심으로 진행)
    
- **봇/비인간 트위터 계정** 탐지는 어떻게 할 수 있는가?
    

---

필요하다면 이 내용을 마크다운 형식으로 정리해드릴 수도 있습니다.