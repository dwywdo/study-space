> 원문: https://engineering.classdojo.com/blog/2015/02/06/rolling-rate-limiter/

ClassDojo에서는 최근 푸시 알림 인프라를 구축하고 있었습니다. 우리가 계획한 시스템에는 다음 조건을 만족하는 **rate limiter**가 필요했습니다:

- **분산 처리 가능성(Distributed)**: 여러 프로세스에서 공유할 수 있는 rate limiter여야 했습니다. 이를 위해 외부 키-값 저장소가 필요했고, 우리는 이미 스택의 다른 부분에서 사용 중이던 Redis를 선택했습니다.
    
- **롤링 윈도우(Rolling Window)**: 예를 들어, 분당 최대 10개의 메시지를 허용한다고 했을 때, 한 사용자가 0:59에 10개의 메시지를 받고 1:01에 또 10개의 메시지를 받는 상황은 막고 싶었습니다.
    
- **메시지 간 최소 간격(Minimum Distance Between Messages)**: 전체적인 속도 제한과 별개로, 연속된 메시지 간에는 최소한의 간격을 두고 싶었습니다. 이는 선생님들이 수업 중에 여러 개의 알림음이나 진동을 짧은 시간에 몰아서 받지 않도록 하기 위함입니다.
    

기존에 나와 있는 rate limiting 옵션들을 찾아보았지만, NPM에서 제공되는 도구들 중에는 위 조건을 모두 만족하는 것이 없었습니다. 그래서 우리는 직접 rate limiter를 만들기로 했고, [여기서 다운로드할 수 있도록 공개](https://www.npmjs.com/package/rolling-rate-limiter)했습니다.

## 첫 번째 시도 – 토큰 버킷(Token Buckets)

롤링 윈도우 기반의 rate limiting을 위한 전형적인 알고리즘은 **토큰 버킷(token bucket)** 또는 그 반대 개념인 **리키 버킷(leaky bucket)**입니다. 작동 방식은 다음과 같습니다:

- 각 사용자에게는 일정 수의 토큰을 담고 있는 버킷이 하나씩 할당됩니다.
    
- 사용자가 어떤 행동을 시도하면, 해당 버킷에 남아 있는 토큰 수를 확인합니다.
    
- 버킷이 비어 있다면, 사용자는 rate를 초과한 것으로 간주되어 해당 행동이 차단됩니다.
    
- 반대로 버킷에 토큰이 남아 있다면, 토큰을 하나(또는 "비용이 큰" 행동일 경우 여러 개) 제거하고, 행동을 허용합니다.
    
- 시간에 따라 모든 사용자의 버킷에 토큰이 일정한 비율로 다시 채워지며, 최대 용량까지 유지됩니다.
    

이 알고리즘은 매우 공간 효율적이며(사용자당 정수 하나만 저장하면 됨) 영리하게 설계되어 있지만, 순진한 구현에는 큰 단점이 있습니다. **버킷을 주기적으로 리필(refill)하는 처리가 필요하다는 점**입니다. 수백만 명의 사용자에 대해 각 리필이 Redis에 쓰기 연산을 발생시키는 구조라면, 이는 Redis 인스턴스에 **지속 불가능한 부하**를 발생시킵니다.

그래서 우리는 좀 더 정교한 방식을 고려했습니다:

- 각 사용자에게는 두 개의 키가 할당됩니다: 하나는 토큰 버킷이고, 다른 하나는 **마지막으로 버킷이 리필된 시간의 타임스탬프**입니다.
    
- 사용자가 행동을 시도하면, 먼저 저장된 타임스탬프를 가져옵니다.
    
- 그 타임스탬스를 기준으로, 그동안 몇 개의 토큰이 새로 지급되었어야 하는지를 계산합니다.
    
- 이 계산된 토큰 수를 바탕으로 기존 알고리즘을 그대로 진행합니다.
    

하지만 이 방식에도 문제는 있습니다. **두 개 이상의 프로세스가 rate limiter를 공유할 경우 동시성 문제가 발생할 수 있다는 점**입니다.

Redis는 여러 연산을 하나의 원자적(atomic)한 동작으로 묶을 수 있지만, 토큰 계산을 위해선 **최소 두 번의 Redis 접근이 필요합니다**:

1. 이전 타임스탬프를 가져오기
    
2. 새로운 토큰 수를 설정하기
    

Redis의 Lua 스크립트를 사용하면 이 문제를 해결할 수 있겠지만, 우리는 Lua에 익숙하지 않았고, 테스트에서 mocking하기도 까다로웠습니다. 따라서 모든 연산을 하나의 원자적 Redis 동작으로 묶는 방법을 찾을 수 없었습니다.

그 결과, 두 클라이언트가 동시에 동일한 사용자에 대한 동작을 검증하려 할 경우 다음과 같은 문제가 발생할 수 있습니다:

1. 사용자는 현재 토큰이 1개 남아 있습니다.
    
2. 마지막 행동 이후 시간이 충분히 지나지 않아, 새 토큰이 지급되지 않은 상태입니다.
    
3. 클라이언트 1이 Redis에서 타임스탬프와 토큰 수를 가져옵니다.
    
4. 클라이언트 2도 동일하게 타임스탬프와 토큰 수를 가져옵니다.
    
5. 클라이언트 1은 추가 토큰이 필요 없다고 판단하고, 행동을 허용한 후 토큰 수를 0으로 설정합니다.
    
6. 클라이언트 2도 같은 판단을 하고, 행동을 허용한 후 Redis에 토큰 수를 0으로 설정합니다.
    

결과적으로, 사용자에게는 두 번의 행동이 동시에 허용된 것입니다. **수십 개의 워커가 동시에 푸시 알림을 처리하고 있다면, 특정 사용자가 한 번에 수십 개의 알림을 받게 되는 스팸성 문제**가 발생할 수 있습니다.

## 더 나은 접근 방식 – **Sorted Set** 사용

다행히도 Redis에는 **경쟁 조건(race condition)**을 방지하는 데 사용할 수 있는 또 다른 자료 구조가 있습니다. 바로 **Sorted Set**입니다. 우리가 고안한 알고리즘은 다음과 같습니다:

1. 각 사용자에 대해 하나의 **Sorted Set**을 유지합니다.  
    이 Set의 key와 value는 모두 같으며, 사용자가 어떤 행동을 시도한 **시간(마이크로초 단위의 타임스탬프)**입니다.
    
2. 사용자가 행동을 시도하면, 먼저 **설정된 간격(interval)** 이전의 요소들을 모두 삭제합니다.  
    이 작업은 Redis의 `ZREMRANGEBYSCORE` 명령어로 처리할 수 있습니다.
    
3. 그런 다음 `ZRANGE 0 -1` 명령으로 Set의 모든 요소를 가져옵니다.
    
4. 현재 시간의 타임스탬프를 Set에 추가합니다. (`ZADD` 사용)
    
5. 이 Set에 대해 **TTL(Time To Live)**을 설정합니다.  
    TTL 값은 rate limiting에 사용된 시간 간격과 동일하게 하여, 메모리를 절약합니다.
    
6. 모든 작업이 완료된 후, 가져온 요소의 개수를 계산합니다.  
    이 개수가 제한값을 초과하면, 해당 행동을 **차단**합니다.
    
7. 또한, 가장 마지막 요소(가장 최근 행동의 타임스탬프)를 현재 시간과 비교합니다.  
    이 두 값이 너무 가깝다면, 해당 행동 역시 **차단**됩니다.
    

---

이 접근 방식의 가장 큰 장점은, 모든 Redis 작업을 하나의 **원자적(atomic)** 트랜잭션으로 묶을 수 있다는 점입니다.  
Redis의 `MULTI` 명령어를 사용하면, 여러 프로세스가 동시에 동일한 사용자에 대한 행동을 처리하려 할 때에도 항상 최신 정보를 기반으로 판단하게 되어, 앞서 언급한 **동시성 문제**를 피할 수 있습니다.

또한, 이 방식은 우리가 필요로 했던 **두 가지 제한 조건**을 모두 처리할 수 있습니다:

- 분당 최대 10건의 메시지
    
- 3초 내 최대 2건의 메시지
    

---

하지만 이 접근 방식에는 하나의 **주의점**이 있습니다.  
우리 팀은 이 점을 받아들일 수 있었지만, 다른 팀에는 적합하지 않을 수도 있습니다.

이 알고리즘에서는 **모든 Redis 작업이 완료된 후에** 행동이 차단될지를 판단합니다.  
즉, 차단된 행동도 Set에 저장되며, **"행동으로 간주"됩니다**.

그 결과, 사용자가 rate limit을 계속 초과할 경우, 초기 몇 번을 제외하면 **모든 행동이 차단되며, 일부라도 허용되는 일이 없습니다.**